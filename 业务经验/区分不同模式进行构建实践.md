# vue-cli

对于vue_cli创建的（基于webpack的）项目，`package.json`中`script`脚本中的比较典型的`serve(vue-cli-service serve)`、`build(vue-cli-service build)`命令会分别以`development`模式和`production`模式来运行，等价于`vue-cli-service serve --mode development`和`vue-cli-service build --mode production`；模式的取值会使项目构建时寻找`.env.模式名`的文件，加载里面的环境变量，然后不管是`vue.config.js(代表服务器端脚本代码)`中还是`main.ts(代表客户端源代码)`，里面都可以通过`process.env.变量名`来访问对应模式下定义的变量



## 举个例子：



### 指定命令模式并定义模式下环境变量

`package.json`（通过`--mode`指定以`test`模式运行命令）：

~~~json
...
"scripts": {
  "serve": "vue-cli-service serve --open --mode test",
  "build": "vue-cli-service build --mode test",
	...
},
...
~~~

根目录下创建`.env.test`（`test`对应模式名）：

~~~
NODE_ENV=development123
jrd666=test
// 变量命名以及取值都非常随意
~~~

### 使用环境变量

`vue.config.js`：

~~~js
...

console.log("@@@@", process.env.NODE_ENV);
console.log("@@@@", process.env.jrd_sts);

...
// 打包构建配置
~~~

执行`npm run build`

命令行输出：

~~~bash
@@@@ development123
@@@@ test
~~~



`main.ts`：

~~~typescript
import ...

console.log("@@@@", process.env.NODE_ENV);
console.log("@@@@", process.env.jrd666);

createApp(App)
	...
~~~

执行`npm run serve`

浏览器控制台输出：

~~~
@@@@ development123
@@@@ undefined
// NODE_ENV修改（之所以说修改，因为默认serve脚本对应development模式，development模式对应NODE_ENV为development）成功了
// 但是随便瞎写的变量并没有定义成功
~~~





## 总结



总而言之这个地方的变量定义规则我是没完全搞明白的，这个具体在vue-cli官方文档都有介绍，但是没有必要完全搞明白啊，应该很少有人在项目的客户端代码中使用环境变量吧，再者说了，我的目的是在项目构建时区分生产环境或者开发环境，所以`process.env.NODE_ENV`能正常修改就已经足够了，我们利用它来区分环境就可以了。



# Vite



对于vite，通过`--mode`手动指定命令的模式并不生效，或者说生效，但`process.env.NODE_ENV`的值不会改变，如下指定`build`脚本以`development`模式执行，并且`.env.development`进行配置如下

`package.json`：

~~~json
"scripts": {
  "dev": "vite --mode develop",
  "build": "vue-tsc && vite build --mode development",
  "test": "vue-tsc && vite build --mode test",
  "preview": "vite preview"
},
~~~

`.env.development`：

~~~
NODE_ENV=development123
VITE_TEST=jrd666
~~~



`main.ts && 执行pnpm dev(develop模式)后的浏览器输出`：

~~~typescript
import { createApp } from 'vue'
import App from './App.vue'

console.log("@@", import.meta.env.MODE); // @@ develop ——> 对于--mode指定的参数，会赋值给客户端代码（web程序）的import.meta.env.MODE
console.log("@@", import.meta.env.VITE_TEST); // @@ jrd666 ——> 对应--mode指定的模式的.env文件中声明的自定义变量会注入到import.meta.env对象中
createApp(App).mount('#app')
~~~



`vite.config.ts && 执行pnpm build(vite build --mode develop)后的命令行输出`：

~~~typescript
console.log("@@@", process.env.NODE_ENV); // @@@ development ——> vite创建的项目中，process.env.NODE_ENV的值不受--mode参数的影响，只要是dev脚本(实际是vite命令)，对应的process.env.NODE_ENV就是development；只要是build脚本（对应vite build命令），对应的process.env.NODE_ENV就是production
console.log("@@@", process.env.VITE_TEST); // @@@ undefined ——> .env文件中的变量不会注入给process.env对象
~~~



## 总结



针对vite创建的项目，客户端代码（web项目）中可以使用`import.meta.env.xxx`访问`--mode`对应模式的`.env`文件中定义的变量值；服务端代码（`vite.config.ts`）中，`process.env.NODE_ENV`的值只跟执行的命令有关，与`--mode`无关，具体来说就是打包命令`process.env.NODE_ENV`就是`production`，本地运行命令`process.env.NODE_ENV`就是`development`。某种角度来说，**这个`process.env.NODE_ENV`已经不是我们用户自由控制的了（对比vue-cli创建的基于webpack的项目中`process.env.NODE_ENV`就是`.env`文件中我们自定义的），所以说`process.env.NODE_ENV`不适合用来区分构建环境。**

